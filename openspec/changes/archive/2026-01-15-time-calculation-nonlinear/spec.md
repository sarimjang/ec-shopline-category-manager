# 時間計算算法改進：非線性成長模型

## 概述

改進 `calculateTimeSaved()` 函數的時間估算算法，使其更真實地反映分類數量對拖動時間的影響。當前算法對分類數的影響過小，導致大型店家（100+ 分類）的時間節省被嚴重低估。

## 問題分析

### 當前算法的不足

**當前公式**（Line 105-112）：
```javascript
dragTime = 4 + (categoryCount / 10) × 0.5 + targetLevel × 1
```

**問題 1：分類數影響太小**

| 分類數 | 層級 | 拖動時間 | 每 10 個分類增加 |
|--------|------|----------|------------------|
| 20 | 2 | 7 秒 | - |
| 100 | 2 | 11 秒 | 0.5 秒 |
| 200 | 2 | 15 秒 | 0.5 秒 |

- 分類數增加 10 倍（20 → 200），拖動時間僅增加 2.14 倍（7 → 15）
- 每增加 10 個分類，只增加 **0.5 秒**
- 不符合真實體驗：200 個分類要捲動很遠才能找到目標位置

**問題 2：忽略視覺搜尋的非線性特性**

認知心理學研究表明，視覺搜尋時間隨項目數增加呈**次線性成長**（sub-linear growth）：
- 小規模（< 20 項目）：幾乎立即找到
- 中規模（50-100 項目）：需要明顯搜尋時間
- 大規模（200+ 項目）：搜尋時間顯著，但不是線性倍增

這種特性通常以**平方根函數**建模：`searchTime ∝ sqrt(n)`

**問題 3：未區分認知負荷與物理操作**

當前算法將所有時間混在一起，但實際上拖動包含兩種不同的成本：
1. **認知成本**：視覺搜尋目標位置（視覺掃描、判斷）
2. **操作成本**：實際捲動和拖動（物理動作）

這兩者的成長曲線不同，應分開建模。

## 解決方案：非線性成長模型

### 新算法設計

**核心公式**：
```javascript
dragTime = baseTime + visualSearchTime + scrollTime + alignmentTime
```

**拆解為四個部分**：

1. **基礎時間**（2 秒）：
   - 抓取元素：0.5 秒
   - 開始拖動：0.5 秒
   - 放開元素：0.5 秒
   - 確認結果：0.5 秒

2. **視覺搜尋時間**（`sqrt(categoryCount) × 0.3`）：
   - 遵循認知心理學的視覺搜尋模型
   - 20 分類：√20 × 0.3 = 1.34 秒
   - 100 分類：√100 × 0.3 = 3 秒
   - 200 分類：√200 × 0.3 = 4.24 秒

3. **捲動時間**（`categoryCount × 0.05`）：
   - 線性成長（捲動距離正比於分類數）
   - 20 分類：20 × 0.05 = 1 秒
   - 100 分類：100 × 0.05 = 5 秒
   - 200 分類：200 × 0.05 = 10 秒

4. **對齊時間**（`targetLevel × 1.5`）：
   - 層級越深，對齊越困難
   - 層級 1：1.5 秒
   - 層級 2：3 秒
   - 層級 3：4.5 秒

**完整公式**：
```javascript
dragTime = 2 + sqrt(categoryCount) × 0.3 + categoryCount × 0.05 + targetLevel × 1.5
```

### 參數設計理由

| 參數 | 值 | 理由 |
|------|-----|------|
| `baseTime` | 2 秒 | 最小拖動操作時間（抓取 + 放開 + 確認）|
| `visualSearchCoeff` | 0.3 | 視覺搜尋係數（基於認知心理學研究）|
| `scrollCoeff` | 0.05 | 捲動係數（每個分類約 0.05 秒捲動時間）|
| `levelCoeff` | 1.5 | 層級係數（從 1.0 增加到 1.5，反映更高難度）|

## 對比分析

### 時間估算比較

| 分類數 | 層級 | 當前算法 | 新算法 | 差異 | 說明 |
|--------|------|----------|--------|------|------|
| 20 | 2 | 7 秒 | **7.3 秒** | +0.3 秒 | 小型店家，差異不大 ✅ |
| 50 | 2 | 8.5 秒 | **11.1 秒** | +2.6 秒 | 中小型店家，捲動開始明顯 |
| 100 | 2 | 11 秒 | **13 秒** | +2 秒 | 中型店家，搜尋 + 捲動顯著 ✅ |
| 200 | 3 | 16.5 秒 | **20.7 秒** | +4.2 秒 | 大型店家，影響顯著 ✅ |
| 500 | 3 | 30.5 秒 | **37.2 秒** | +6.7 秒 | 超大型店家，工具價值更高 |

### 節省時間影響

假設工具時間固定為 3.5 秒（不使用搜尋）：

| 分類數 | 層級 | 當前節省 | 新算法節省 | 差異 |
|--------|------|----------|------------|------|
| 20 | 2 | 3.5 秒 | 3.8 秒 | +0.3 秒 |
| 100 | 2 | 7.5 秒 | 9.5 秒 | +2 秒 ✅ |
| 200 | 3 | 13 秒 | 17.2 秒 | +4.2 秒 ✅ |

**關鍵洞察**：
- ✅ 小型店家（20 分類）：影響極小（+0.3 秒）
- ✅ 大型店家（200 分類）：時間節省增加 32%（13 → 17.2 秒）
- ✅ 更真實反映工具對大型店家的價值

## 認知科學依據

### 視覺搜尋的平方根法則

**研究基礎**：
- Treisman & Gelade (1980): *Feature Integration Theory*
- Wolfe (1994): *Guided Search Model*

**核心發現**：
1. **串聯搜尋**（Serial Search）：需要逐一檢查項目
   - 搜尋時間 ∝ n（線性成長）
   - 適用於：複雜特徵組合、相似項目

2. **平行搜尋**（Parallel Search）：可同時處理多個項目
   - 搜尋時間 ∝ 1（常數時間）
   - 適用於：單一特徵、高對比項目

3. **引導搜尋**（Guided Search）：實際情況介於兩者之間
   - 搜尋時間 ∝ sqrt(n)（次線性成長）
   - 適用於：有線索輔助的搜尋（如分類名稱的字母順序）

**在分類移動場景中**：
- 用戶知道目標分類名稱（有線索）
- 分類按字母或建立時間排序（有結構）
- 但仍需視覺掃描確認位置
- → **符合引導搜尋模型**，使用平方根函數建模 ✅

### 捲動時間的線性成長

**物理操作特性**：
- 捲動距離正比於分類數
- 捲動速度基本恆定（受瀏覽器限制）
- → **線性成長** ✅

## 技術規格

### 修改位置

**檔案**：`src/shopline-category-manager.user.js`

**函數**：`calculateTimeSaved(categoryCount, targetLevel, usedSearch)`

**行號**：Line 104-125（約 22 行）

### 新程式碼

```javascript
/**
 * 計算時間節省（非線性成長模型）
 *
 * 模型設計：
 * - 視覺搜尋：sqrt(categoryCount) - 認知心理學研究表明視覺搜尋時間呈次線性成長
 * - 捲動時間：線性成長 - 捲動距離正比於分類數
 * - 對齊時間：層級越深越困難
 *
 * @param {number} categoryCount - 分類總數（影響視覺搜尋和捲動時間）
 * @param {number} targetLevel - 目標層級 1-3（影響對齊難度）
 * @param {boolean} usedSearch - 是否使用搜尋功能
 * @returns {{dragTime: number, toolTime: number, timeSaved: number}}
 */
function calculateTimeSaved(categoryCount, targetLevel, usedSearch) {
  // 時間組成部分
  const baseTime = 2;                                    // 基礎操作時間（抓取 + 放開 + 確認）
  const visualSearchTime = Math.sqrt(categoryCount) * 0.3; // 視覺搜尋時間（非線性）
  const scrollTime = categoryCount * 0.05;               // 捲動時間（線性）
  const alignmentTime = targetLevel * 1.5;               // 對齊時間（層級影響）

  const dragTime = baseTime + visualSearchTime + scrollTime + alignmentTime;

  // 工具時間 = 2.5秒（使用搜尋）或 3.5秒（瀏覽選單）
  const toolTime = usedSearch ? 2.5 : 3.5;

  // 節省時間 = max(0, 拖動時間 - 工具時間)
  const timeSaved = Math.max(0, dragTime - toolTime);

  return {
    dragTime: Math.round(dragTime * 10) / 10,  // 四捨五入到小數點一位
    toolTime: Math.round(toolTime * 10) / 10,
    timeSaved: Math.round(timeSaved * 10) / 10
  };
}
```

### 效能影響

**新增運算**：
- `Math.sqrt()` 調用：1 次
- 乘法運算：4 次（vs 當前 3 次）

**效能評估**：
- `Math.sqrt()` 為原生優化函數，速度極快（< 0.01ms）
- 移動操作本身需 2000-3000ms
- 計算時間 < 0.1ms，影響**可忽略** ✅

## 驗證計劃

### Phase 1: 理論驗證

**目標**：確認新算法在各種場景下的合理性

**測試案例**：

| 場景 | 分類數 | 層級 | 預期拖動時間 | 預期節省時間 | 驗證標準 |
|------|--------|------|--------------|--------------|----------|
| 極小店家 | 10 | 1 | 4.4 秒 | 0.9 秒 | 應該很少節省時間 ✅ |
| 小型店家 | 20 | 2 | 7.3 秒 | 3.8 秒 | 工具有明顯價值 ✅ |
| 中型店家 | 50 | 2 | 11.1 秒 | 7.6 秒 | 工具價值顯著 ✅ |
| 大型店家 | 100 | 2 | 13 秒 | 9.5 秒 | 工具價值高 ✅ |
| 超大店家 | 200 | 3 | 20.7 秒 | 17.2 秒 | 工具價值極高 ✅ |
| 極端案例 | 500 | 3 | 37.2 秒 | 33.7 秒 | 工具不可或缺 ✅ |

**驗證方法**：
1. 手動計算所有案例
2. 確認沒有負數或異常值
3. 確認小型店家影響小，大型店家影響大

### Phase 2: 實作驗證

**目標**：確認程式碼修改正確且無副作用

**步驟**：
1. 修改 `calculateTimeSaved()` 函數
2. 語法驗證（`node -c`）
3. 手動測試：
   - 移動分類，檢查 Toast 訊息
   - 確認節省時間計算正確
   - 確認累積統計正確

### Phase 3: 真實環境驗證

**目標**：從真實用戶獲得反饋

**方法**：
1. 部署到 production
2. 觀察 1-2 週使用數據
3. 收集用戶反饋
4. 必要時微調參數

**可調參數**：
```javascript
const visualSearchCoeff = 0.3;  // 可調整範圍 0.2-0.4
const scrollCoeff = 0.05;       // 可調整範圍 0.03-0.07
const levelCoeff = 1.5;         // 可調整範圍 1.0-2.0
```

## 向後相容性

### 完全相容 ✅

- 函數簽名不變：`calculateTimeSaved(categoryCount, targetLevel, usedSearch)`
- 返回值結構不變：`{dragTime, toolTime, timeSaved}`
- localStorage 格式不變
- UI 顯示邏輯不變

### 數據連續性

**統計累積**：
- 舊數據（舊算法計算）：保留
- 新數據（新算法計算）：累加
- 結果：混合統計，但仍有意義（代表「至少節省這麼多時間」）

**重置選項**：
- 用戶可隨時透過 Tampermonkey 選單重置統計
- 重新開始累積（使用新算法）

## 風險評估

### 低風險 ✅

1. **功能風險**：無
   - 純計算邏輯修改
   - 不影響移動功能本身

2. **效能風險**：可忽略
   - `Math.sqrt()` 極快
   - 計算時間 < 0.1ms

3. **相容性風險**：無
   - 函數簽名不變
   - 返回值結構不變

4. **用戶體驗風險**：極低
   - 節省時間變大 → 用戶感覺更好
   - 更準確反映工具價值

## 成功標準

### 必須滿足

1. ✅ **程式碼正確**
   - 語法驗證通過
   - 無運行時錯誤
   - 同步到 prod.user.js

2. ✅ **計算準確**
   - 所有測試案例通過
   - 無負數或 NaN
   - 邊界條件正確

3. ✅ **用戶體驗**
   - Toast 訊息正確顯示
   - 統計累積正確
   - 無效能問題

### 期望達成

1. ✅ **準確性提升**
   - 大型店家（100+ 分類）的時間估算更真實
   - 用戶反饋「時間估算比較準」

2. ✅ **激勵效果**
   - 看到更高的節省時間
   - 更願意使用工具

## 參考資料

### 認知心理學研究

1. Treisman, A. M., & Gelade, G. (1980). *A feature-integration theory of attention*. Cognitive Psychology, 12(1), 97-136.

2. Wolfe, J. M. (1994). *Guided Search 2.0: A revised model of visual search*. Psychonomic Bulletin & Review, 1(2), 202-238.

3. Palmer, J. (1995). *Attention in visual search: Distinguishing four causes of a set-size effect*. Current Directions in Psychological Science, 4(4), 118-123.

### 相關程式碼

- `src/shopline-category-manager.user.js`
  - Line 104-125: `calculateTimeSaved()` 函數
  - Line 180-192: `TimeSavingsTracker.recordMove()` 方法
  - Line 1567: 移動成功時的調用點

### OpenSpec 相關變更

- `time-savings-tracker`: 基礎時間追蹤功能（Phase 1 & 2）
- `tampermonkey-sandbox-fix`: 修復 production 版本沙箱問題

## 實作優先級

**建議順序**：

1. ✅ 先完成 `tampermonkey-sandbox-fix` 文檔更新和 push
2. → 實作本變更（時間算法改進）
3. → 驗證和部署
4. → 收集反饋和微調

**時程估計**：
- Phase 1（理論驗證）：30 分鐘
- Phase 2（實作驗證）：30 分鐘
- Phase 3（真實驗證）：1-2 週觀察期
- **總計**：~2 小時（開發時間）+ 1-2 週（觀察期）
