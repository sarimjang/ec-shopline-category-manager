---
phase: 01-extension-mvp
plan: 03
type: execute
domain: chrome-extension
---

<objective>
Implement Storage API abstraction layer, complete CategoryManager with move logic, and build Popup UI with statistics display.

Purpose: Storage abstraction replaces localStorage, CategoryManager handles category operations (critical feature), Popup provides user interface for viewing stats and controls.

Output:
- `src/shared/storage.js` - chrome.storage.local abstraction
- Complete CategoryManager with working moveCategory() and API integration
- Popup UI with stats display, reset button, settings placeholder
- Real-time stats propagation from content script to popup
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/checkpoints.md
.planning/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@openspec/changes/add-chrome-extension-export-import/design.md
@openspec/changes/add-chrome-extension-export-import/specs/extension-core/spec.md
@openspec/changes/add-chrome-extension-export-import/specs/category-operations/spec.md

**Key References from design.md:**
- Storage structure: categoryMoveStats { totalMoves, totalTimeSaved, lastReset }
- Shopline API: PUT /api/admin/v1/{shopId}/categories/{categoryId}/ordering
- Payload: { parent, ancestor, descendant }
- AngularJS $scope.$apply() required after updates

**Spec Requirements:**
- Storage API Abstraction (extension-core)
- Popup Statistics Display (extension-core)
- Category Move Operation (category-operations)

**CRITICAL from design.md:**
- Do NOT hand-roll retry logic yet (that's Phase 2)
- Conservative 200ms delays between API calls
- Time-saved formula: sqrt(count)*0.3 + count*0.05 + level*1.5 + 2.5
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Storage API abstraction layer</name>
  <files>src/shared/storage.js</files>
  <action>
Create storage abstraction to replace localStorage:

```javascript
// src/shared/storage.js
class StorageManager {
  // Statistics storage
  async getStats() {
    return new Promise((resolve) => {
      chrome.storage.local.get(['categoryMoveStats'], (result) => {
        resolve(result.categoryMoveStats || {
          totalMoves: 0,
          totalTimeSaved: 0,
          lastReset: new Date().toISOString()
        });
      });
    });
  }

  async setStats(stats) {
    return new Promise((resolve) => {
      chrome.storage.local.set({ categoryMoveStats: stats }, resolve);
    });
  }

  async addMove(timeSaved) {
    const stats = await this.getStats();
    stats.totalMoves += 1;
    stats.totalTimeSaved += timeSaved;
    await this.setStats(stats);
    return stats;
  }

  async resetStats() {
    const stats = {
      totalMoves: 0,
      totalTimeSaved: 0,
      lastReset: new Date().toISOString()
    };
    await this.setStats(stats);
    return stats;
  }

  // Export/Import history (Phase 2 prep)
  async getHistory(type) { // 'exports' or 'imports'
    return new Promise((resolve) => {
      chrome.storage.local.get([type], (result) => {
        resolve(result[type] || []);
      });
    });
  }

  async addToHistory(type, entry) {
    const history = await this.getHistory(type);
    history.unshift(entry); // Newest first
    if (history.length > 100) history.pop(); // Keep last 100
    await new Promise((resolve) => {
      chrome.storage.local.set({ [type]: history }, resolve);
    });
  }
}

export const storage = new StorageManager();
```

Avoid: Don't use promises with callbacks (use async/await consistently). Don't store large objects—keep stats minimal. Don't forget to handle async operations properly.
  </action>
  <verify>
- storage.js loads without errors
- Storage methods callable (test getStats(), addMove(1.5), resetStats())
- chrome.storage.local responds correctly (verify via popup console)
  </verify>
  <done>
- StorageManager fully functional
- Stats persist after page reload
- History management working (prep for Phase 2)
- All Promise-based operations working
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete CategoryManager with category move and API integration</name>
  <files>src/content/injected.js (update CategoryManager)</files>
  <action>
Update CategoryManager skeleton with working moveCategory() method:

```javascript
async moveCategory(categoryId, newParent, newPosition) {
  try {
    // 1. Extract shopId from URL
    const shopId = this.extractShopIdFromUrl();
    if (!shopId) throw new Error('Cannot extract shopId from URL');

    // 2. Build API payload
    const payload = {
      parent: newParent,
      ancestor: newParent, // Shopline API expects both
      descendant: categoryId
    };

    // 3. Call Shopline API with 200ms conservative delay
    const response = await this.callApiWithDelay(
      `PUT /api/admin/v1/${shopId}/categories/${categoryId}/ordering`,
      payload
    );

    if (!response.ok) throw new Error(`API error: ${response.status}`);

    // 4. Update local state (before API response)
    this.updateLocalState(categoryId, newParent, newPosition);

    // 5. Trigger AngularJS $apply() for DOM update
    this.$rootScope.$apply();

    // 6. Calculate time saved and update stats
    const timeSaved = this.calculateTimeSaved(
      this.categories.length,
      this.getTargetLevel(newParent)
    );

    // 7. Store updated stats
    const newStats = await storage.addMove(timeSaved);
    this.stats = newStats;

    // 8. Broadcast to popup
    this.broadcastStats();

    return { success: true, timeSaved, stats: newStats };
  } catch (error) {
    console.error('[CategoryManager] Move failed:', error);
    this.broadcastError(error.message);
    throw error;
  }
}

// Helper methods
extractShopIdFromUrl() {
  // Extract from /admin/{shopId}/categories
  const match = window.location.pathname.match(/\/admin\/([^\/]+)\/categories/);
  return match ? match[1] : null;
}

async callApiWithDelay(endpoint, payload) {
  // Wait 200ms before calling (conservative rate limit)
  await new Promise(r => setTimeout(r, 200));
  
  // Simple fetch for now (no retry in Phase 1)
  const url = `https://${window.location.host}/api${endpoint.split(' ')[1]}`;
  return fetch(url, {
    method: endpoint.split(' ')[0],
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
}

updateLocalState(categoryId, newParent, newPosition) {
  // Update this.categories tree locally
  // Find category, update parent/position
  // Details depend on current structure
}

getTargetLevel(parentId) {
  // Return nesting level of target parent
  // 1 = root level, 2 = child of root, 3 = grandchild
  return parentId ? 2 : 1; // Placeholder - calculate from tree
}

broadcastStats() {
  window.dispatchEvent(new CustomEvent('categoryStats', {
    detail: { stats: this.stats }
  }));
}

broadcastError(message) {
  window.dispatchEvent(new CustomEvent('categoryError', {
    detail: { error: message }
  }));
}
```

Avoid: Don't add retry logic yet (Phase 2-05). Don't hardcode host names. Don't forget $apply() call. Don't assume category data structure—keep it generic.
  </action>
  <verify>
- moveCategory() method callable and doesn't throw on basic inputs
- API call happens with correct delay
- $apply() triggers AngularJS updates
- Stats updated in storage
- Events broadcast successfully
  </verify>
  <done>
- Category move fully functional
- API integration working
- Stats tracking operational
- Events properly broadcast to content script and popup
  </done>
</task>

<task type="auto">
  <name>Task 3: Build Popup UI with statistics display</name>
  <files>src/popup/popup.html, src/popup/popup.js, src/popup/popup.css</files>
  <action>
Create popup interface:

**popup.html:**
```html
<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="popup.css">
</head>
<body>
  <div class="container">
    <h1>Shopline Categories</h1>
    
    <div class="stats">
      <div class="stat-item">
        <span class="label">Moves Today:</span>
        <span class="value" id="totalMoves">0</span>
      </div>
      <div class="stat-item">
        <span class="label">Time Saved:</span>
        <span class="value" id="timeSaved">0 min 0 sec</span>
      </div>
      <div class="stat-item">
        <span class="label">Avg per Move:</span>
        <span class="value" id="avgTime">0 sec</span>
      </div>
    </div>

    <div class="buttons">
      <button id="resetBtn" class="btn btn-secondary">Reset Stats</button>
      <button id="settingsBtn" class="btn btn-secondary">Settings</button>
    </div>

    <div id="status" class="status"></div>
  </div>

  <script src="popup.js"></script>
</body>
</html>
```

**popup.css:**
```css
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  width: 300px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  background: #f9fafb;
  color: #111827;
}

.container { padding: 16px; }

h1 {
  font-size: 16px;
  margin-bottom: 16px;
  text-align: center;
}

.stats {
  background: white;
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 16px;
  border: 1px solid #e5e7eb;
}

.stat-item {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid #f3f4f6;
}

.stat-item:last-child { border-bottom: none; }

.label { font-weight: 500; color: #6b7280; }
.value { font-weight: 700; color: #1f2937; }

.buttons {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-bottom: 12px;
}

.btn {
  padding: 8px 12px;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  font-weight: 500;
}

.btn-secondary {
  background: white;
  color: #374151;
  border: 1px solid #d1d5db;
}

.btn-secondary:hover { background: #f3f4f6; }

.status {
  font-size: 12px;
  padding: 8px;
  border-radius: 4px;
  text-align: center;
  min-height: 20px;
}

.status.success { background: #d1fae5; color: #065f46; }
.status.error { background: #fee2e2; color: #991b1b; }
```

**popup.js:**
```javascript
import { storage } from '../shared/storage.js';

// Load stats on popup open
async function loadStats() {
  const stats = await storage.getStats();
  updateUI(stats);

  // Listen for stat updates from content script
  window.addEventListener('categoryStats', (e) => {
    updateUI(e.detail.stats);
  });
}

function updateUI(stats) {
  const { totalMoves = 0, totalTimeSaved = 0 } = stats;
  
  document.getElementById('totalMoves').textContent = totalMoves;
  
  // Format time saved: convert seconds to min:sec
  const minutes = Math.floor(totalTimeSaved / 60);
  const seconds = Math.floor(totalTimeSaved % 60);
  document.getElementById('timeSaved').textContent = 
    `${minutes} min ${seconds} sec`;
  
  // Average time per move
  const avgSeconds = totalMoves > 0 
    ? Math.floor(totalTimeSaved / totalMoves)
    : 0;
  document.getElementById('avgTime').textContent = `${avgSeconds} sec`;
}

// Reset button
document.getElementById('resetBtn').addEventListener('click', async () => {
  if (confirm('Reset all statistics?')) {
    await storage.resetStats();
    loadStats();
    showStatus('Stats reset', 'success');
  }
});

// Settings button (placeholder for Phase 2)
document.getElementById('settingsBtn').addEventListener('click', () => {
  showStatus('Settings coming soon', 'error');
});

function showStatus(message, type = 'success') {
  const el = document.getElementById('status');
  el.textContent = message;
  el.className = `status ${type}`;
  setTimeout(() => { el.textContent = ''; el.className = 'status'; }, 2000);
}

// Load stats when popup opens
loadStats();
```

Avoid: Don't make popup too complex (keep it lightweight). Don't hardcode colors—stick to gray/blue palette. Don't forget to handle missing stats gracefully.
  </action>
  <verify>
- popup.html valid and renders without errors
- popup.js loads and can fetch stats
- Stats display formats correctly (time in min:sec)
- Reset button triggers confirmation and clears stats
- UI responds to category stat events
  </verify>
  <done>
- Popup displays statistics correctly
- Stats update in real-time from category operations
- Reset button works with confirmation
- UI responsive and visually clean
- Ready for Service Worker integration (Phase 1-04)
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] StorageManager all methods working (test in popup console)
- [ ] CategoryManager.moveCategory() executes without errors
- [ ] Popup displays stats (use test data)
- [ ] Stats persist after popup close/reopen
- [ ] Reset button clears stats correctly
- [ ] No console errors in content script or popup
</verification>

<success_criteria>

- Storage abstraction fully functional
- Category move operation complete with API integration
- Stats tracking and persistence working
- Popup UI displays stats with proper formatting
- Real-time event propagation from content to popup
- Ready for Service Worker phase (01-04)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-extension-mvp/01-03-SUMMARY.md`:

# Phase 1.3 Plan 3: Storage, CategoryManager, and Popup Summary

**Storage API abstraction, category move logic, and statistics popup completed**

## Accomplishments

- chrome.storage.local abstraction replaces localStorage
- CategoryManager.moveCategory() implements Shopline API integration
- Popup UI displays real-time statistics
- Stats tracking and persistence working
- Event-driven communication between content script and popup

## Files Created/Modified

- `src/shared/storage.js` - Storage abstraction layer
- `src/content/injected.js` - CategoryManager with move logic
- `src/popup/popup.html` - Popup interface
- `src/popup/popup.js` - Popup logic with stat updates
- `src/popup/popup.css` - Popup styling

## Decisions Made

- Used Promise-based async/await for storage operations
- Conservative 200ms API delays (per design.md)
- Popup auto-updates via CustomEvent listener
- Stats formatted as human-readable time strings

## Issues Encountered

None

## Next Step

Ready for 01-04-PLAN.md: Service Worker initialization and integration testing
</output>
