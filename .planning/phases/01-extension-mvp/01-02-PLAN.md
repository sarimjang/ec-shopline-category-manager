---
phase: 01-extension-mvp
plan: 02
type: execute
domain: chrome-extension
---

<objective>
Implement Content Script and AngularJS access bridge using injected script pattern.

Purpose: Content scripts cannot directly access page AngularJS due to sandbox isolation. The injected script pattern (MAIN world) allows bridging while maintaining security boundary.

Output:
- `src/content/content.js` - Content script (isolated world)
- `src/content/injected.js` - Injected script (MAIN world, accesses page AngularJS)
- Event-based communication between content/injected scripts
- CategoryManager class skeleton prepared for porting
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/checkpoints.md
.planning/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@openspec/changes/add-chrome-extension-export-import/design.md
@openspec/changes/add-chrome-extension-export-import/specs/extension-core/spec.md

**Key Pattern from design.md:**
Content script loads injected script into MAIN world, establishes CustomEvent bridge for communication. Injected script accesses window.angular, dispatches events back to content script.

**Spec Requirements (extension-core/spec.md):**
- Content Script Execution
- AngularJS access via injected script

**Existing Code Reference:**
- Current UserScript uses unsafeWindow.angular (Tampermonkey sandbox bypass)
- Will adapt CategoryManager logic from existing script
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Content Script with injected script loader</name>
  <files>src/content/content.js, src/manifest.json (update to reference content.js)</files>
  <action>
Create src/content/content.js that:

1. Detects if running on Shopline category page:
   - Check if URL contains /admin/ and /categories
   - Only proceed if true (early exit if wrong page)

2. Loads injected script into MAIN world:
   ```javascript
   const script = document.createElement('script');
   script.src = chrome.runtime.getURL('src/content/injected.js');
   script.onload = () => script.remove();
   (document.head || document.documentElement).appendChild(script);
   ```

3. Establishes event listeners for communication:
   ```javascript
   window.addEventListener('categoryActionMessage', (event) => {
     const { type, data } = event.detail;
     // Handle category actions (moves, stats updates)
     // Forward to service worker if needed
   });
   ```

4. Sets up message listener for background script:
   ```javascript
   chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
     if (request.type === 'GET_PAGE_STATE') {
       // Return current category data if available
     }
   });
   ```

5. Minimal logging (console.log for development, prepare for logger.js integration):
   - "Content script loaded on [URL]"
   - Any page detection failures

Avoid: Don't try to access window.angular directly (won't work in content script). Don't add heavy processing here (keep it lightweight). Don't hardcode specific URLs beyond /admin/*/categories pattern.
  </action>
  <verify>
- content.js loads without syntax errors
- Script is referenced in manifest.json content_scripts
- Injected script successfully injected (verify in manifest point_and_click)
  </verify>
  <done>
- Content script properly detects Shopline category pages
- Injected script injection mechanism working
- Event listeners registered (no errors in console)
- Message passing structure established
  </done>
</task>

<task type="auto">
  <name>Task 2: Create injected script with AngularJS bridge and CategoryManager skeleton</name>
  <files>src/content/injected.js</files>
  <action>
Create src/content/injected.js that:

1. Accesses page AngularJS (in MAIN world):
   ```javascript
   const angular = window.angular;
   const injector = angular.injector(['ng', 'app']);
   const $rootScope = injector.get('$rootScope');
   // Get controller/scope as needed
   ```

2. Defines CategoryManager skeleton (core structure only):
   ```javascript
   class CategoryManager {
     constructor($scope, $http) {
       this.$scope = $scope;
       this.$http = $http;
       this.categories = [];
       this.stats = { totalMoves: 0, timeSaved: 0 };
     }

     async moveCategory(categoryId, newParent, newPosition) {
       // Will be implemented in Phase 1 Task 3
       // For now: method signature + logging
       console.log(`[CategoryManager] moveCategory called: ${categoryId}`);
     }

     calculateTimeSaved(categoryCount, targetLevel) {
       // Formula from design.md:
       // visual: sqrt(categoryCount) * 0.3
       // scroll: categoryCount * 0.05
       // alignment: targetLevel * 1.5
       // tool overhead: 2.5s (search) or 3.5s (browse)
       return Math.sqrt(categoryCount) * 0.3 
            + categoryCount * 0.05 
            + targetLevel * 1.5 
            + 2.5;
     }

     broadcastStats() {
       // Dispatch CustomEvent to content script
       window.dispatchEvent(new CustomEvent('categoryStats', {
         detail: { stats: this.stats }
       }));
     }
   }
   ```

3. Initializes CategoryManager on page load:
   ```javascript
   window.addEventListener('DOMContentLoaded', () => {
     if (window.angular) {
       window.categoryManager = new CategoryManager($scope, $http);
       console.log('[Injected] CategoryManager initialized');
     }
   });
   ```

4. Exports window.categoryManager for access via CustomEvents

5. Minimal logging:
   - "Injected script loaded"
   - Angular access success/failure
   - CategoryManager initialization status

Avoid: Don't try to move categories yet (Phase 1 Task 3). Don't add UI manipulation (popup handles that). Don't assume all pages have Angular (add try/catch).
  </action>
  <verify>
- injected.js loads without syntax errors
- window.angular accessible (inject check passes)
- CategoryManager class defined and instantiable
- Stats broadcasting mechanism working
  </verify>
  <done>
- Injected script successfully accesses page AngularJS
- CategoryManager skeleton in place with time-saved calculation
- Event bridge established between injected â†” content scripts
- Ready for Phase 1 Task 3 (category move implementation)
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] content.js and injected.js exist with no syntax errors
- [ ] Scripts run on Shopline category pages (check DevTools console)
- [ ] window.angular successfully accessed in injected.js
- [ ] No "Uncaught in isolated world" errors
- [ ] CustomEvent bridge tested (dispatch/listen working)
</verification>

<success_criteria>

- Content script properly loads on target pages
- Injected script successfully accesses window.angular
- CategoryManager skeleton defined with key methods
- Event-based communication pattern established
- Ready for category move implementation (Phase 1-03)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-extension-mvp/01-02-SUMMARY.md`:

# Phase 1.2 Plan 2: Content Script & AngularJS Bridge Summary

**Content Script and injected script implemented with AngularJS access bridge**

## Accomplishments

- Content script detects Shopline category pages
- Injected script successfully accesses page AngularJS
- CategoryManager skeleton with time-saved calculation
- CustomEvent-based communication pattern established

## Files Created/Modified

- `src/content/content.js` - Content script with injected script loader
- `src/content/injected.js` - Injected script with CategoryManager skeleton
- `src/manifest.json` - Updated with content_scripts entry

## Decisions Made

- Used injected script pattern (MAIN world) for AngularJS access (vs unsafe workarounds)
- CustomEvent for cross-world communication (vs message passing overhead)
- CategoryManager skeleton preserves key methods for Phase 1-03

## Issues Encountered

None

## Next Step

Ready for 01-03-PLAN.md: Storage API abstraction, category move implementation, and Popup UI
</output>
