---
phase: 01-extension-mvp
plan: 01
type: execute
domain: chrome-extension
---

<objective>
Set up Chrome Extension project structure and Manifest V3 configuration.

Purpose: Establish the foundation for all other Extension components. Manifest V3 requires proper permissions, host matching, and script declarations upfront.

Output: 
- `manifest.json` with MV3 structure
- Basic project directory structure
- Icon assets (16x16, 48x48, 128x128)
- Empty placeholder content/popup/background scripts
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/checkpoints.md
.planning/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@openspec/changes/add-chrome-extension-export-import/design.md
@openspec/changes/add-chrome-extension-export-import/specs/extension-core/spec.md

**Key Reference from design.md:**
- Manifest V3 required for future API support (SidePanel, Service Workers)
- Permissions needed: storage, contextMenus, sidePanel
- Host permissions: *.shoplineapp.com, *.shopline.tw, *.shopline.app
- Content script injection point: /admin/*/categories*

**Spec Requirements (extension-core/spec.md):**
- Chrome Extension Installation & Activation
- Manifest V3 Configuration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Manifest V3 and project structure</name>
  <files>manifest.json, src/manifest.json (if separate), package.json (if new build), directory structure</files>
  <action>
Create the following structure:
```
src/
├── manifest.json              # Manifest V3 config
├── content/
│   ├── content.js             # Content script (loads injected script)
│   └── injected.js            # Injected script (accesses window.angular)
├── popup/
│   ├── popup.html
│   ├── popup.js
│   └── popup.css
├── background/
│   └── service-worker.js      # Service Worker
├── assets/
│   ├── icon-16.png
│   ├── icon-48.png
│   └── icon-128.png
└── shared/
    ├── storage.js             # Storage API abstraction
    ├── constants.js
    └── logger.js

manifest.json structure:
- manifest_version: 3
- name: "Shopline Category Manager"
- version: "1.0.0"
- description: "Bulk manage Shopline store categories"
- permissions: ["storage", "contextMenus"]
- host_permissions: ["*://app.shoplineapp.com/*", "*://app.shopline.tw/*", "*://app.shopline.app/*"]
- action: { default_title: "Shopline Categories", default_icon: "assets/icon-128.png" }
- background: { service_worker: "src/background/service-worker.js" }
- content_scripts: [{ matches: ["*://app.shoplineapp.com/admin/*/categories*", ...], js: ["src/content/content.js"] }]

Avoid: Don't use Manifest V2 (deprecated). Don't hardcode URLs (use *:// wildcards). Don't mix host_permissions with permissions.
  </action>
  <verify>
- manifest.json exists and is valid JSON (no parse errors)
- Directory structure complete with all subdirectories
- Icon files exist (placeholder PNGs acceptable for now)
- manifest.json contains all required MV3 fields
  </verify>
  <done>
- manifest.json valid and parseable
- All directories created
- Icons present (size/quality acceptable)
- File structure matches design.md layout
  </done>
</task>

<task type="auto">
  <name>Task 2: Initialize package.json with build tooling (if needed)</name>
  <files>package.json, .gitignore (if new), build script placeholder</files>
  <action>
Check if project has package.json. If not, create one with:
- name: "shopline-category-manager"
- version: "1.0.0"
- description: "Chrome Extension for bulk Shopline category management"
- scripts: { "build": "echo 'Build steps TBD'" }
- devDependencies: {} (empty for now - we're not bundling the Extension code yet)

If package.json exists, verify it doesn't conflict with Extension structure.

Create .gitignore for Extension:
- node_modules/
- dist/ (if future build output)
- *.zip (Web Store submissions)
- .env.local

Avoid: Don't add heavy build tools yet (webpack, TypeScript). Keep it simple for MVP. We'll enhance if needed in Phase 2+.
  </action>
  <verify>
- package.json exists and is valid JSON
- .gitignore includes common patterns
- No build errors from package.json syntax
  </verify>
  <done>
- package.json valid and readable
- .gitignore in place
- Project ready for development
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cat src/manifest.json` shows valid MV3 structure
- [ ] All directories in src/ exist with `ls -R src/`
- [ ] Icons visible in src/assets/ directory
- [ ] No TypeScript/build errors (none expected at this stage)
</verification>

<success_criteria>

- Project structure complete and organized
- manifest.json valid and compliant with MV3 spec
- All required directories created
- Icon assets in place (placeholder acceptable)
- Ready for content script implementation (Phase 01-02)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-extension-mvp/01-01-SUMMARY.md`:

# Phase 1.1 Plan 1: Project Setup Summary

**Chrome Extension project initialized with Manifest V3 structure and icon assets**

## Accomplishments

- Project directory structure created
- Manifest V3 configured with permissions, host patterns, scripts
- Icon assets added (16x16, 48x48, 128x128)
- Build tooling scaffolded (package.json, .gitignore)

## Files Created

- `src/manifest.json` - MV3 manifest with all required fields
- `src/content/content.js` - Content script placeholder
- `src/content/injected.js` - Injected script placeholder
- `src/popup/popup.html`, `popup.js`, `popup.css` - Popup UI placeholders
- `src/background/service-worker.js` - Service Worker placeholder
- `src/shared/storage.js`, `constants.js`, `logger.js` - Utility placeholders
- `src/assets/icon-*.png` - Icon set
- `package.json` - Build config
- `.gitignore` - Git config

## Decisions Made

- MV3 chosen (vs V2) for longevity and API access
- Project uses simple directory structure (no bundler yet)
- Chrome Web Store-compliant naming and icons

## Issues Encountered

None

## Next Step

Ready for 01-02-PLAN.md: Content Script implementation and AngularJS bridging
</output>
